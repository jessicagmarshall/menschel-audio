{"ast":null,"code":"// Hi Welcome to WFI by David Jones / RackFX, LLC\nvar fs = require('fs');\n\nvar wfi = {};\n\nwfi.infoByFilename = function (filename, cb) {\n  var stats = fs.statSync(filename);\n  var buffer = new Buffer(40); // first 40 bytes are RIFF header\n\n  fs.open(filename, 'r', function (err, fd) {\n    if (err) return cb(err); // error probably TODO:check this!\n    // ex error -\n    // { [Error: ENOENT: no such file or directory, open './test.wav'] errno: -2, code: 'ENOENT', syscall: 'open', path: './test.wav' }\n\n    var read_result = {}; // this a list of sequenced bytes in the 40 byte header. This builds the read_result object.\n    //  Property name / Data type / Length\n\n    var reads = [['riff_head', 'string', 4], ['chunk_size', 'uinteger', 4], ['wave_identifier', 'string', 4], ['fmt_identifier', 'string', 4], ['subchunk_size', 'integer', 4], ['audio_format', 'integer', 2], ['num_channels', 'integer', 2], ['sample_rate', 'uinteger', 4], ['byte_rate', 'integer', 4], ['block_align', 'integer', 2], ['bits_per_sample', 'integer', 2], //['uhm','integer',2],\n    ['data_identifier', 'string', 4]];\n    fs.read(fd, buffer, 0, 40, 0, function (err, num) {\n      var i = 0;\n      var pointer = 0;\n\n      function read_wav() {\n        var read = reads[i];\n        i++;\n\n        if (read[1] == 'string') {\n          read_result[read[0]] = buffer.toString('ascii', pointer, pointer + read[2]);\n          pointer = pointer + read[2]; // pointer = pointer plus # bytes\n        } else if (read[1] == 'integer') {\n          read_result[read[0]] = buffer.readUInt16LE(pointer, read[2]);\n          pointer = pointer + read[2];\n        } else if (read[1] == 'uinteger') {\n          read_result[read[0]] = buffer.readInt32LE(pointer, read[2]);\n          pointer = pointer + read[2];\n        }\n\n        if (i < reads.length) {\n          return read_wav();\n        } else {\n          return post_process();\n        }\n      } //console.log(i)\n\n\n      read_wav();\n    }); // end fs.read\n\n    function post_process() {\n      var error = false;\n      var invalid_reasons = [];\n      if (read_result.riff_head != \"RIFF\") invalid_reasons.push(\"Expected \\\"RIFF\\\" string at 0\");\n      if (read_result.wave_identifier != \"WAVE\") invalid_reasons.push(\"Expected \\\"WAVE\\\" string at 4\");\n      if (read_result.fmt_identifier != \"fmt \") invalid_reasons.push(\"Expected \\\"fmt \\\" string at 8\");\n      if (read_result.audio_format != 1 && // Wav\n      read_result.audio_format != 65534 && // Extensible PCM\n      read_result.audio_format != 2 && // Wav\n      read_result.audio_format != 22127 && // Vorbis ?? (issue #11)\n      read_result.audio_format != 3) // Wav\n        invalid_reasons.push(\"Unknown format: \" + read_result.audio_format);\n      if (read_result.chunk_size + 8 !== stats.size) invalid_reasons.push(\"chunk_size does not match file size\"); //if ((read_result.data_identifier) != \"data\") invalid_reasons.push(\"Expected data identifier at the end of the header\")\n\n      if (invalid_reasons.length > 0) error = true;\n      if (error) return cb({\n        error: true,\n        invalid_reasons: invalid_reasons,\n        header: read_result,\n        stats: stats\n      });\n      cb(null, {\n        header: read_result,\n        stats: stats,\n        duration: read_result.chunk_size / (read_result.sample_rate * read_result.num_channels * (read_result.bits_per_sample / 8))\n      });\n    }\n  });\n};\n\nmodule.exports = wfi;","map":null,"metadata":{},"sourceType":"script"}